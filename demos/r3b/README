
           Computation of Periodic Solutions of the CR3BP
           ----------------------------------------------

 Running the Python script r3b.auto will generate the families of periodic 
 solutions L1, H1, and V1, for the case of the mass-ratio mu=0.063 :

 	auto r3b.auto			| auto('r3b.auto')

 where as in the following examples, the left hand side command can be used
 at the shell prompt, and the right hand side command at the Python CLUI
 prompt. Note that the commands starting with @ work in both interfaces,
 but cannot be used in the expert scripts with a .py suffix.

 For example, the data generated for the Lyapunov family L1 will consist of

	b.L1	-  the bifurcation diagram data
	s.L1	-  a selection of periodic orbits
	d.L1	-  diagnostic data, including Floquet multipliers

 The necessary labeled starting solutions are first computed and stored
 in the file s.start. Each starting solution is an equilibrium ("libration
 point"), and its data also contains the period of a bifurcating family of
 periodic orbits.
 The Table below shows the label of each of the starting solutions in 
 s.start, indicating which libration point it corresponds to, and which 
 family of periodic orbits it will generate:

		Label	Libration Pt.	Family
		  1	    L1		  L1
	  	  2         L1		  V1
	  	  3         L2		  L2
	  	  4         L2		  V2
	  	  5         L3		  L3
	  	  6         L3		  V3
	  	  7         L4		  V4
	  	  8         L5		  V5

 Note (by looking at the constant-files c.r3b.*) that actually only the 
 starting solutions labeled 1 and 2 are used in the current calculations, 
 as executed by the Python script.

 Starting solution for other values of mu can be generated using the script
 compute_lps.py, for instance by running

	autox compute_lps.py 0.05	| import compute_lps
					| compute_lps.compute(0.05)

 After that, it is necessary to run r3b.auto again to regenerate the
 families.

 The demos L1a, H1a, H1b, H1c, V1a, V1b can be run subsequent to the r3b
 demo to compute 2D unstable manifolds of selected periodic orbits that
 belong to the L1, V1, and H1 families.


    Computing Unstable Manifolds of Periodic Orbits in the CR3BP
    ------------------------------------------------------------

 Instructions for computing 2-d unstable manifolds of periodic orbits 
 in the Circular Restricted 3-Body Problem (CR3BP) using AUTO-07p. 

 The instructions below are for the Halo family L1 in AUTO demo L1a.
 ===================================================================

 Instructions for computing 2-d unstable manifolds of other periodic 
 orbits in the CR3BP are similar (Demos H1a, H1b, H1c, V1a, V1b), and
 are given after these instructions.

 Select a labeled solution which has exactly one Floquet multiplier with
 absolute value greater than 1. (Floquet multipliers can be found in the file
 d.L1 generated by demo r3b.) Enter the label of the periodic solution
 in the file L1a.auto at label= in L1a.auto. Also enter the size of the
 initial step into the direction of the unstable manifold there at step=
 Note that representative values of these three quantities have already
 been entered there.
 Now run the Python script L1a.auto:

	auto L1a.auto			| auto('L1a.auto')

 This will run r3b.auto as above if this was not already done.

 Through various computational steps the execution of the Python script
 will result in AUTO files b.L1a, s.L1a, and d.L1a, where the orbits in 
 s.L1a constitute the manifold, which can be viewed with the graphics 
 program plaut04 or r3bplaut04 :

	@pl L1a or             @r3b L1a | plot3('L1a',r3b=True)

 The various steps executed by the Python commands in the script file
 L1a.auto are explained below, however, showing instead the equivalent 
 Linux versions of these AUTO commands.

 The Python script L1aX.auto in L1a does the same as L1a.auto, but with 
 additional calculations that generate additional AUTO data files, e.g., 
 to detect heteroclinic connections. Some of these additional runs take 
 quite a bit of CPU time and generate big data files.
----------------------------------------------------------------------------
----------------------------------------------------------------------------

               Detailed AUTO shell and Python commands for the L1a demo.
               ---------------------------------------------------------

mkdir r3b		| mkdir r3b
cd r3b			| cd r3b
@dm r3b			| demo('r3b')

		Copy the r3b demo to the local directory r3b.

auto r3b.auto		| auto('r3b.auto')

		Generate the CR3BP AUTO data files.

autox ext.py L1 3 -1e-5 | import ext
			| sext=ext.get('L1',3,-1e-5)

		Convert the data for a selected labeled solution from s.L1, 
		adding a zero adjoint variable. The solution label is 3,
                and the initial step size into the unstable manifold is -1e-5.
		The ext.py script looks for the relevant Floquet multiplier in
		d.L1. The converted solution will be written in the file s.ext
		or stored in sext.

@r flq ext		| flq=run(sext,c='flq',e='flq')

		Compute the Floquet eigenfunction. Free scalar variables in
		this run (see c.flq) are: 

		PAR(1) = unfolding parameter 
		PAR(4) = multiplier
		PAR(5) = norm of eigenfunction

		If this run is successful then PAR(5) should become nonzero,
		in fact, PAR(5) should reach the value 1.  If the run is 
		not successful then see REMARK 1 below.

@sv flq			| save(flq,'flq')

		Save the results in b.flq, s.flq, and d.flq .

autox data.py		| import data
			| startman=data.get(flq('UZ1'))

		Extract data for a selected orbit from s.flq. These data 
		are for both the orbit and its Floquet eigenfunction. It 
		is assumed that s.flq contains only one labeled solution, 
		with label 2. If you did the "optional" computation (see 
		Remark 2) then you may need to change the label of the 
		restart solution:
                   autox data.py flq n		| startman=data.get(flq(n))
		where n is the different label number.
                The extracted data may be saved in a file called s.startman,
                which contains a new starting solution that can be used as
		a base for the manifold computations.
                The orbit coordinates are at "time zero", and the Floquet
		eigenfunction are saved at PAR(25:30) and PAR(31:36),
		respectively.

@R man L1a.0 startman | startL1a = run(startman,e='man',c='man.L1a.0')

                This step does a time integration using continuation in the
                "period" T, i.e., PAR(11), which here is the "integration
                time". The labeled solutions from this run all correspond
                to the same orbit, except that the orbit gets longer and
                longer. The starting point of the orbit is the point on the
                periodic orbit at "time zero" plus a small distance (epsilon)
                into the direction of the unstable manifold. In AUTO, epsilon
                corresponds to PAR(6). This parameter epsilon is initialized
                in the file flq.dat . (The sign of epsilon is significant!)
                The parameters in this run (see c.man.L1a.0) are:

		PAR(3)  = energy
		PAR(11) = integration time
		PAR(12) = length of the orbit
		PAR(21) = x-coord at end point
		PAR(22) = y-coord at end point
		PAR(23) = z-coord at end point

@sv startL1a		| save(startL1a,'startL1a')

		Save the results in b.startL1a, s.startL1a, and d.startL1a . (*)

@R man L1a.1 startL1a	| L1a=run(startL1a,c='man.L1a.1')

		Look at c.man.L1a.1 to see from which label in s.startL1a this
		run starts. In this run the y-coordinate of the end point 
		(PAR(22)) is kept fixed, while the "period" (PAR(11)), 
		i.e., the total integration time, is allowed to vary, as 
		is the value of epsilon, i.e., PAR(6). Note that if PAR(6) 
		becomes "large" then the manifold may no longer be accurate.
		The free parameters in this run are:

		PAR(3)  = energy
		PAR(6)  = "starting distance"
		PAR(11) = integration time
		PAR(12) = length of the orbit
		PAR(21) = x-coord at end point
		PAR(23) = z-coord at end point

@sv L1a			| save(L1a,'L1a')

		Save the results in b.L1a, s.L1a, and d.L1a .

@R man L1a.2 startL1a	| L1a2=run(startL1a,c='man.L1a.2')

		Another run, starting from a longer initial orbit, which 
		computes part of the manifold. The free parameters are the 
		same as in the preceding run. This computation results in 
		the orbit winding around the selected periodic L1 orbit.

@sv L1a2 		| save(L1a2,'L1a2')

		Save the results in b.L1a2, s.L1a2, and d.L1a2 .

----------------------------------------------------------------------------
----------------------------------------------------------------------------

Use

auto clean.auto		| auto('clean.auto')

to remove all generated files.

----------------------------------------------------------------------------
----------------------------------------------------------------------------
----------------------------REMARK 1----------------------------------------
----------------------------------------------------------------------------
----------------------------------------------------------------------------
 If the run to compute the Floquet eigenfunction is not successful, i.e., if 
 PAR(5) does not become nonzero, then try to compute the Floquet eigenfunction
 in more stages, as follows:
 
		Give the label of the selected solution, and a value that 
		is smaller than the associated Floquet multiplier (magnitude
		greater than 1) .

autox ext.py L1 3 -1e-5 2000 | import ext
			     | sext=ext.get('L1',3,-1e-5,2000)
@R flq 2 ext		     | flq=run(sext,c='flq.2',e='flq')

		Continue the approximate multiplier; If all goes well then 
		the actual multiplier will be detected as a branch point 
		(BP) with Label 2. Free scalar variables in this run are: 

		PAR(1) = unfolding parameter 
		PAR(4) = multiplier
		PAR(5) = norm of eigenfunction

@sv flq			     | save(flq,'flq')
@R flq 3		     | flq=run(flq,e='flq',c='flq.3')

		Switch branches at the BP, thereby generating the nonzero 
		Floquet eigenfunction. The free scalar variables are : 

		PAR(1) = unfolding parameter 
		PAR(4) = multiplier
		PAR(5) = norm of eigenfunction

		If all goes well then PAR(5) should become nonzero, and the
		corresponding solution should have Label 4.

@sv flq			     | save(flq,'flq')
----------------------------------------------------------------------------
----------------------------------------------------------------------------
----------------------------REMARK 2----------------------------------------
----------------------------------------------------------------------------
----------------------------------------------------------------------------
 One can also follow the orbit, its multiplier and eigenfunction, as follows:

@R flq 4		     | flq=run(flq,e='flq',c='flq.3')

		Free scalar variables in this run are

		PAR(1)  = unfolding parameter 
		PAR(4)  = multiplier
		PAR(11) = period

		The norm, PAR(5), of the eigenfunction is fixed in this run.

@sv flq			     | save(flq,'flq')
----------------------------------------------------------------------------
----------------------------------------------------------------------------

 The instructions below are for the Halo family H1 in AUTO demo H1a.
 ===================================================================

 Follow the instructions for L1a above, where you replace L by H throughout,
 for instance you can run everything in one go using

	auto H1a.auto			| auto('H1a.auto')

 or with the extra calculations:

	auto H1aX.auto			| auto('H1aX.auto')

 The Floquet eigenfunction is now computed from label 7 with step size -1e-3.

 The detailed commands are likewise, except for the manifold calculations
 following (*) (at @sv startL1a):

@R man H1a.1 startH1a	| H1a=run(startH1a,e='man',c='man.H1a.1')

		Look at c.man.H1a.1 to see from which label in s.startH1a this
		run starts. In this run the x-coordinate of the end point 
		(PAR(21)) is kept fixed, while the "period" (PAR(11)), 
		i.e., the total integration time, is allowed to vary, as 
		is the value of epsilon, i.e., PAR(6). Note that if PAR(6) 
		becomes "large" then the manifold may no longer be accurate.
		The free parameters in this run are:

		PAR(3)  = energy
		PAR(6)  = "starting distance"
		PAR(11) = integration time
		PAR(12) = length of the orbit
		PAR(22) = y-coord at end point
		PAR(23) = z-coord at end point

@sv H1a			| save(H1a,'H1a')

		Save the results in b.H1a, s.H1a, and d.H1a .

@R man H1a.2 startH1a	| hetH1a=run(startH1a,e='man',c='man.H1a.2')

		Another run, starting from a longer initial orbit, which 
		computes part of the manifold. The free parameters are the 
		same as in the preceding run. This computation results in 
		the detection of a connecting orbit.

@sv hetH1a 		| save(hetH1a,'hetH1a')

		Save the results in b.hetH1a, s.hetH1a, and d.hetH1a .
----------------------------------------------------------------------------
----------------------------------------------------------------------------

 The instructions below are for the Halo family H1 in AUTO demo H1b.
 ===================================================================

 Follow the instructions for L1a above, where you replace L by H, and a by b
 throughout; for instance you can run everything in one go using

	auto H1b.auto			| auto('H1b.auto')

 or with the extra calculations:

	auto H1bX.auto			| auto('H1bX.auto')

 The Floquet eigenfunction is now computed from label 3 with step size -1e-5.

 The detailed commands follow the ones for H1a above, except that there
 is one extra run:

@R man H1b.3 startH1b	| het2H1b=run(startH1b,e='man',c='man.H1b.3')

		Another run, starting from a longer initial orbit, which 
		computes part of the manifold. The free parameters are the 
		same as in the preceding run. This computation results in 
		the detection of another connecting orbit.

@sv het2H1b	    	| save(het2H1b,'het2H1b')

		Save the results in b.het2H1b, s.het2H1b, and d.het2H1b .
----------------------------------------------------------------------------
----------------------------------------------------------------------------

 The instructions below are for the Halo family H1 in AUTO demo H1c.
 ===================================================================

 Follow the instructions for L1a above, where you replace L by H, and a by c
 throughout; for instance you can run everything in one go using

	auto H1c.auto			| auto('H1c.auto')

 The Floquet eigenfunction is now computed from label 68 with step size -1e-2.

 The detailed commands follow the ones for H1a above, except that the last
 run is left out, and so the H1cX.auto script is not necessary.

----------------------------------------------------------------------------
----------------------------------------------------------------------------

 The instructions below are for the Halo family V1 in AUTO demo V1a.
 ===================================================================

 Follow the instructions for L1a above, where you replace L by V throughout,
 for instance you can run everything in one go using

	auto V1a.auto			| auto('V1a.auto')

 The Floquet eigenfunction is now computed from label 8 with step size -1e-5.

 The detailed commands are likewise, except for the manifold calculations
 following (*) (at @sv startL1a):

@R man V1a.1 startV1a	| V1a=run(startV1a,e='man',c='man.V1a.1')

		Look at c.man.V1a.1 to see from which label in s.startV1a this
		run starts. In this run the z-coordinate of the end point 
		(PAR(23)) is kept fixed, while the "period" (PAR(11)), 
		i.e., the total integration time, is allowed to vary, as 
		is the value of epsilon, i.e., PAR(6). Note that if PAR(6) 
		becomes "large" then the manifold may no longer be accurate.
		The free parameters in this run are:

		PAR(3)  = energy
		PAR(6)  = "starting distance"
		PAR(11) = integration time
		PAR(12) = length of the orbit
		PAR(21) = x-coord at end point
		PAR(22) = y-coord at end point

@sv V1a			| save(V1a,'V1a')

		Save the results in b.V1a, s.V1a, and d.V1a .
----------------------------------------------------------------------------
----------------------------------------------------------------------------

 The instructions below are for the Halo family V1 in AUTO demo V1b.
 ===================================================================

 Follow the instructions for L1a above, where you replace L by V, and a by b
 throughout; for instance you can run everything in one go using

	auto V1b.auto			| auto('V1b.auto')

 or with the extra calculations:

	auto V1bX.auto			| auto('V1bX.auto')

 The Floquet eigenfunction is now computed from label 12 with step size 1e-5.

 The detailed commands are likewise, except for the manifold calculations
 following (*) (at @sv startL1a):

@R man V1b.1 startV1b	| V1b=run(startV1b,e='man',c='man.V1b.1')

		Look at c.man.V1b.1 to see from which label in s.startV1b this
		run starts. In this run the x-coordinate of the end point 
		(PAR(21)) is kept fixed, while the "period" (PAR(11)), 
		i.e., the total integration time, is allowed to vary, as 
		is the value of epsilon, i.e., PAR(6). Note that if PAR(6) 
		becomes "large" then the manifold may no longer be accurate.
		The free parameters in this run are:

		PAR(3)  = energy
		PAR(6)  = "starting distance"
		PAR(11) = integration time
		PAR(12) = length of the orbit
		PAR(22) = y-coord at end point
		PAR(23) = z-coord at end point

@sv V1b			| save(V1b,'V1b')

		Save the results in b.V1b, s.V1b, and d.V1b .

@R man V1b.2 startV1b	| hetV1b=run(startV1b,e='man',c='man.V1b.2')

		Another run, starting from a longer initial orbit, which 
		computes part of the manifold. The free parameters are the 
		same as in the preceding run. This computation results in 
		the detection of a connecting orbit.

@sv hetV1b		| save(hetV1b,'hetV1b')

		Save the results in b.hetV1b, s.hetV1b, and d.hetV1b .
----------------------------------------------------------------------------
----------------------------------------------------------------------------
